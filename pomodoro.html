<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pomodoro Focus Timer</title>
    <style>
        body { font-family: sans-serif; margin: 0; padding: 0; }
        h1, h3 { margin-top: 0; margin-bottom: 5px; }
        .container { max-width: 800px; margin: 0 auto; padding: 5px; }
        .section { margin-bottom: 10px; padding: 10px; border: 1px solid #eee; position: relative; }
        .control-bar { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .progress-bar-container { height: 12px; background-color: #f0f0f0; border: 1px solid #ccc; margin-top: 10px; border-radius: 3px; }
        .progress-bar-fill { height: 100%; background-color: #000000; transition: width 0.3s ease-in-out; border-radius: 3px; }
        button { padding: 8px 12px; border: 1px solid #ccc; background-color: #f9f9f9; cursor: pointer; }
        button:hover { background-color: #e9e9e9; }
        input[type="text"], input[type="number"] { padding: 8px 12px; border: 1px solid #ccc; }
        .hidden { display: none; }
        [contenteditable]:focus, input:focus { outline: 2px solid black; }
        .btn-row { display: flex; gap: 6px; flex-wrap: wrap; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 8px; }
        .muted { color: #666; font-size: 12px; }
        .big-time { font-variant-numeric: tabular-nums; font-size: 40px; letter-spacing: 1px; }
        ul { list-style: none; padding-left: 0; }
        li { margin-bottom: 6px; }
        

    </style>
    <link rel="icon" href="data:," />
    <meta name="color-scheme" content="light" />
    <script src="encrypted-storage.js"></script>
</head>
<body>
    <div class="container" id="main-container">
        <div class="section">
            <div class="control-bar">
                <div style="flex:1">
                    <div>
                        <span id="overall-progress-text">0/0 sessions</span>
                    </div>
                    <div class="progress-bar-container">
                        <div id="overall-progress-bar" class="progress-bar-fill"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="section">
            <h3>Settings</h3>
            <div class="grid">
                <div>
                    <label>Focus (min):</label>
                    <input type="number" id="focusDuration" value="25" min="0.1" max="120" step="0.1">
                </div>
                <div>
                    <label>Break (min):</label>
                    <input type="number" id="shortBreakDuration" value="5" min="0.1" max="30" step="0.1">
                </div>
            </div>
        </div>

        <div class="section">
            <div style="text-align: center; padding: 30px;">
                <div style="font-size: 48px; font-weight: bold; margin-bottom: 8px; font-family: 'Courier New', monospace;" id="timer-display">25:00</div>
                <div style="font-size: 18px; color: #666; margin-bottom: 20px;" id="session-type">Focus Session</div>
                <div class="btn-row" style="justify-content: center; margin: 20px 0;">
                    <button id="start-btn" onclick="startTimer()" style="background: #10b981; color: white; font-weight: bold;">‚ñ∂ Start</button>
                    <button id="pause-btn" onclick="pauseTimer()" disabled style="background: #f59e0b; color: white;">‚è∏ Pause</button>
                    <button id="reset-btn" onclick="resetTimer()">üîÑ Reset</button>
                    <button id="stop-alarm-btn" onclick="stopAlarm()" style="display: none; background: #dc2626; color: white; font-weight: bold; padding: 12px 20px; border: none; border-radius: 6px; cursor: pointer; margin: 0 5px;">üîá Stop Alarm</button>
                </div>
                <div class="progress-bar-container">
                    <div id="timer-progress-bar" class="progress-bar-fill" style="width: 0%;"></div>
                </div>
            </div>
        </div>

        <div class="section">
            <h3>Today's Progress</h3>
            <div class="grid">
                <div>
                    <strong>Sessions:</strong>
                    <div id="today-stats">0</div>
                </div>
                <div>
                    <strong>Focus Time:</strong>
                    <div id="focus-time-today">0 min</div>
                </div>
            </div>
        </div>
    </div>



    <!-- Audio elements for notifications -->
    <audio id="timer-complete-sound" preload="auto">
        <source src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmhADyxjvfLOeSsFJHfH8N2QQAo0aLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAo0aLvt559NEA" type="audio/wav">
    </audio>

    <script>
        // Global state
        let timerState = {
            isRunning: false,
            isPaused: false,
            currentSession: 'focus', // 'focus', 'shortBreak', 'longBreak'
            timeLeft: 25 * 60, // seconds
            sessionCount: 0,
            completedSessions: 0,
            totalSessions: 0
        };

        let timerInterval = null;
        let alarmInterval = null;
        let audioContext = null;
        let alarmStarting = false; // Flag to prevent multiple alarms
        let storage = null;
        let pomodoroData = {
            sessions: [],
            settings: {
                focusDuration: 25,
                shortBreakDuration: 5,
                longBreakDuration: 15,
                sessionsUntilLongBreak: 4
            },
            stats: {
                totalFocusSessions: 0,
                totalFocusTime: 0
            }
        };

        // Initialize storage
        async function initStorage() {
            try {
                if (typeof EncryptedStorage !== 'undefined') {
                    storage = new EncryptedStorage();
                } else {
                    // Fallback storage
                    storage = {
                        async saveEncrypted(key, data) {
                            localStorage.setItem(key, JSON.stringify(data));
                            return true;
                        },
                        async loadEncrypted(key) {
                            const data = localStorage.getItem(key);
                            return data ? JSON.parse(data) : null;
                        }
                    };
                }
                await loadData();
                await restoreTimerState();
                
                // Ensure functions exist before calling them
                if (typeof updateDisplay === 'function') {
                    updateDisplay();
                } else {
                    console.error('updateDisplay function not found');
                }
                
                if (typeof updateProgress === 'function') {
                    updateProgress();
                } else {
                    console.error('updateProgress function not found');
                }
                
                if (typeof updateStats === 'function') {
                    updateStats();
                } else {
                    console.error('updateStats function not found');
                }
            } catch (error) {
                console.error('Storage initialization failed:', error);
            }
        }

        // Load data from storage
        async function loadData() {
            try {
                const data = await storage.loadEncrypted('pomodoro-data');
                if (data) {
                    pomodoroData = { ...pomodoroData, ...data };
                }
                
                // Apply loaded settings
                document.getElementById('focusDuration').value = pomodoroData.settings.focusDuration;
                document.getElementById('shortBreakDuration').value = pomodoroData.settings.shortBreakDuration;
                
                updateDisplay();
                updateStats();
                updateProgress();
            } catch (error) {
                console.error('Failed to load data:', error);
            }
        }

        // Save data to storage
        async function saveData() {
            try {
                await storage.saveEncrypted('pomodoro-data', pomodoroData);
                showAutoSaveIndicator();
            } catch (error) {
                console.error('Failed to save data:', error);
            }
        }

        // Save timer state to session storage for persistence across tool switches
        function saveTimerState() {
            const stateToSave = {
                ...timerState,
                timestamp: Date.now()
            };
            sessionStorage.setItem('pomodoro-timer-state', JSON.stringify(stateToSave));
        }

        // Restore timer state from session storage
        async function restoreTimerState() {
            try {
                const savedState = sessionStorage.getItem('pomodoro-timer-state');
                if (savedState) {
                    const parsedState = JSON.parse(savedState);
                    
                    // Check if the saved state is recent (within last hour)
                    const now = Date.now();
                    const stateAge = now - (parsedState.timestamp || 0);
                    const oneHour = 60 * 60 * 1000;
                    
                    if (stateAge < oneHour) {
                        // Restore the timer state
                        timerState.currentSession = parsedState.currentSession || 'focus';
                        timerState.timeLeft = parsedState.timeLeft || (25 * 60);
                        timerState.sessionCount = parsedState.sessionCount || 0;
                        timerState.completedSessions = parsedState.completedSessions || 0;
                        timerState.totalSessions = parsedState.totalSessions || 0;
                        
                        // If timer was running, we'll pause it and let user resume
                        if (parsedState.isRunning) {
                            timerState.isPaused = true;
                            timerState.isRunning = false;
                            
                            // Calculate elapsed time while away
                            const elapsedWhileAway = Math.floor((now - parsedState.timestamp) / 1000);
                            timerState.timeLeft = Math.max(0, timerState.timeLeft - elapsedWhileAway);
                            
                            // Show resume notification after a short delay
                            setTimeout(() => {
                                if (timerState.timeLeft > 0) {
                                    if (confirm(`Timer was running when you left (${formatTime(timerState.timeLeft)} remaining). Resume from where you left off?`)) {
                                        startTimer();
                                    }
                                } else {
                                    alert('Timer completed while you were away! Starting next session...');
                                    handleTimerComplete();
                                }
                            }, 500);
                        }
                    }
                }
            } catch (error) {
                console.log('Could not restore timer state:', error);
            }
        }

        function showAutoSaveIndicator() {
            const indicator = document.getElementById('auto-save-indicator');
            if (indicator) {
                indicator.style.opacity = '1';
                setTimeout(() => {
                    indicator.style.opacity = '0';
                }, 2000);
            }
            // If indicator doesn't exist, silently continue (simplified UI)
        }

        // Timer functions
        function startTimer() {
            if (!timerState.isRunning) {
                // Stop any active alarm
                stopAlarm();
                
                // Update settings before starting
                updateSettings();
                
                if (!timerState.isPaused) {
                    // Starting fresh timer
                    const duration = getCurrentSessionDuration();
                    timerState.timeLeft = duration * 60;
                }
                
                timerState.isRunning = true;
                timerState.isPaused = false;
                
                timerInterval = setInterval(tick, 1000);
                
                document.getElementById('start-btn').disabled = true;
                document.getElementById('pause-btn').disabled = false;
                
                saveTimerState(); // Save state when starting
            }
        }

        function pauseTimer() {
            if (timerState.isRunning) {
                // Stop any active alarm
                stopAlarm();
                
                timerState.isRunning = false;
                timerState.isPaused = true;
                clearInterval(timerInterval);
                
                document.getElementById('start-btn').disabled = false;
                document.getElementById('pause-btn').disabled = true;
                
                saveTimerState(); // Save state when pausing
            }
        }

        function resetTimer() {
            // Stop any active alarm
            stopAlarm();
            
            timerState.isRunning = false;
            timerState.isPaused = false;
            clearInterval(timerInterval);
            
            const duration = getCurrentSessionDuration();
            timerState.timeLeft = duration * 60;
            
            updateDisplay();
            updateTimerProgress();
            
            document.getElementById('start-btn').disabled = false;
            document.getElementById('pause-btn').disabled = true;
            
            saveTimerState(); // Save state when resetting
        }

        function skipSession() {
            completeSession();
        }

        function tick() {
            timerState.timeLeft--;
            updateDisplay();
            updateTimerProgress();
            
            // Save state every 10 seconds to maintain persistence
            if (timerState.timeLeft % 10 === 0) {
                saveTimerState();
            }
            
            if (timerState.timeLeft <= 0) {
                completeSession();
            }
        }

        // Start looping alarm (ensures only one alarm can run)
        function startAlarm() {
            try {
                // Prevent multiple alarms from starting simultaneously
                if (alarmStarting) {
                    console.log('Alarm already starting, ignoring duplicate call');
                    return;
                }
                
                console.log('Starting alarm...');
                alarmStarting = true;
                
                // Stop any existing alarms but preserve the starting flag
                if (alarmInterval) {
                    clearInterval(alarmInterval);
                    alarmInterval = null;
                }
                
                if (audioContext) {
                    try {
                        audioContext.close();
                    } catch (error) {
                        console.log('Could not close audio context:', error);
                    }
                    audioContext = null;
                }
                
                // Small delay to ensure cleanup is complete
                setTimeout(() => {
                    try {
                        // Initialize fresh audio context
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        
                        // Resume audio context if needed (required by some browsers)
                        if (audioContext.state === 'suspended') {
                            audioContext.resume().then(() => {
                                console.log('Audio context resumed');
                            });
                        }
                        
                        console.log('Audio context state:', audioContext.state);
                        
                        // Start new alarm interval
                        alarmInterval = setInterval(() => {
                            playAlarmBeep();
                        }, 1000); // Beep every second
                        
                        // Play first beep immediately
                        playAlarmBeep();
                        
                        // Show manual stop button
                        const stopButton = document.getElementById('stop-alarm-btn');
                        if (stopButton) {
                            stopButton.style.display = 'inline-block';
                        }
                        
                        alarmStarting = false; // Reset flag
                        console.log('Alarm started successfully - beeping should be audible');
                    } catch (innerError) {
                        alarmStarting = false;
                        console.error('Failed to create alarm:', innerError);
                    }
                }, 100);
            } catch (error) {
                alarmStarting = false; // Reset flag on error
                console.log('Could not start alarm:', error);
            }
        }
        
        // Play a more alarming sound sequence
        function playAlarmBeep() {
            try {
                if (!audioContext) {
                    console.log('No audio context available for alarm beep');
                    return;
                }
                
                console.log('Playing alarm beep...');
                
                // Create multiple oscillators for a more urgent sound
                const frequencies = [800, 1200, 800]; // Alternating high-low pattern
                const duration = 0.15; // Shorter, more urgent beeps
                
                frequencies.forEach((freq, index) => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    const startTime = audioContext.currentTime + (index * duration);
                    
                    oscillator.frequency.setValueAtTime(freq, startTime);
                    gainNode.gain.setValueAtTime(0.2, startTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + duration);
                    
                    oscillator.start(startTime);
                    oscillator.stop(startTime + duration);
                });
                
                console.log('Alarm beep scheduled successfully');
                
            } catch (error) {
                console.error('Could not play alarm beep:', error);
            }
        }
        
        // Stop the looping alarm - ensures ALL alarms are cleared
        function stopAlarm() {
            // Reset starting flag immediately
            alarmStarting = false;
            
            // Clear the primary alarm interval (multiple times to be sure)
            if (alarmInterval) {
                clearInterval(alarmInterval);
                alarmInterval = null;
            }
            
            // Force clear any potential duplicated intervals by trying multiple times
            clearInterval(alarmInterval);
            clearInterval(alarmInterval);
            clearInterval(alarmInterval);
            
            // Reset alarm interval variable completely
            alarmInterval = null;
            
            // Recreate audio context fresh (this stops any ongoing audio)
            if (audioContext) {
                try {
                    audioContext.close();
                } catch (error) {
                    console.log('Could not close audio context:', error);
                }
                audioContext = null;
            }
            
            // Hide manual stop button
            const stopButton = document.getElementById('stop-alarm-btn');
            if (stopButton) {
                stopButton.style.display = 'none';
            }
            
            console.log('All alarms stopped - complete cleanup performed');
        }
        
        // Popup notification removed - using only browser notification and alarm
        


        // Show browser notification
        function showNotification() {
            const sessionType = timerState.currentSession === 'focus' ? 'Focus session' : 'Break';
            const nextType = timerState.currentSession === 'focus' ? 'break' : 'focus session';
            
            // Request notification permission if not granted
            if ('Notification' in window) {
                if (Notification.permission === 'granted') {
                    new Notification('Pomodoro Timer', {
                        body: `${sessionType} complete! Time for ${nextType}.`,
                        icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23f59e0b"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/></svg>',
                        tag: 'pomodoro-timer',
                        requireInteraction: false
                    });
                } else if (Notification.permission !== 'denied') {
                    Notification.requestPermission().then(permission => {
                        if (permission === 'granted') {
                            showNotification(); // Retry showing notification
                        }
                    });
                }
            }
        }

        function completeSession() {
            timerState.isRunning = false;
            timerState.isPaused = false;
            clearInterval(timerInterval);
            
            // Record session
            const session = {
                type: timerState.currentSession,
                completedAt: new Date().toISOString(),
                duration: getCurrentSessionDuration()
            };
            
            pomodoroData.sessions.unshift(session);
            
            // Update stats
            if (timerState.currentSession === 'focus') {
                timerState.completedSessions++;
                pomodoroData.stats.totalFocusSessions++;
                pomodoroData.stats.totalFocusTime += getCurrentSessionDuration();
            }
            
            // Move to next session type
            nextSession();
            
            // Save data and timer state
            saveData();
            saveTimerState();
            
            // Update UI
            updateDisplay();
            updateStats();
            updateProgress();
            
            // Start alarm FIRST, then show browser notification
            startAlarm();
            
            // Show browser notification immediately (appears in taskbar)
            showNotification();
            
            document.getElementById('start-btn').disabled = false;
            document.getElementById('pause-btn').disabled = true;
        }

        function nextSession() {
            if (timerState.currentSession === 'focus') {
                // After focus session, take a break
                timerState.currentSession = 'shortBreak';
            } else {
                // After break, back to focus
                timerState.currentSession = 'focus';
            }
            
            const duration = getCurrentSessionDuration();
            timerState.timeLeft = duration * 60;
        }

        function getCurrentSessionDuration() {
            switch (timerState.currentSession) {
                case 'focus':
                    return pomodoroData.settings.focusDuration;
                case 'shortBreak':
                    return pomodoroData.settings.shortBreakDuration;
                default:
                    return 25;
            }
        }

        function updateSettings() {
            pomodoroData.settings.focusDuration = parseFloat(document.getElementById('focusDuration').value) || 25;
            pomodoroData.settings.shortBreakDuration = parseFloat(document.getElementById('shortBreakDuration').value) || 5;
            
            // Update timer display if not running
            if (!timerState.isRunning && !timerState.isPaused) {
                const currentDuration = getCurrentSessionDuration();
                timerState.timeLeft = currentDuration * 60;
                updateDisplay();
                updateTimerProgress();
            }
            
            saveData();
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function updateDisplay() {
            document.getElementById('timer-display').textContent = formatTime(timerState.timeLeft);
            
            let sessionLabel = '';
            switch (timerState.currentSession) {
                case 'focus':
                    sessionLabel = 'Focus Session';
                    break;
                case 'shortBreak':
                    sessionLabel = 'Break Time';
                    break;
                default:
                    sessionLabel = 'Focus Session';
                    break;
            }
            document.getElementById('session-type').textContent = sessionLabel;
        }

        function updateTimerProgress() {
            const totalDuration = getCurrentSessionDuration() * 60;
            const elapsed = totalDuration - timerState.timeLeft;
            const progress = (elapsed / totalDuration) * 100;
            document.getElementById('timer-progress-bar').style.width = `${Math.max(0, Math.min(100, progress))}%`;
        }

        function updateProgress() {
            const today = new Date().toDateString();
            const todaySessions = pomodoroData.sessions.filter(s => 
                s.type === 'focus' && new Date(s.completedAt).toDateString() === today
            ).length;
            
            document.getElementById('overall-progress-text').textContent = `${todaySessions} sessions today`;
            
            // Show progress as percentage of daily goal (e.g., 8 sessions = 100%)
            const dailyGoal = 8;
            const progress = Math.min((todaySessions / dailyGoal) * 100, 100);
            document.getElementById('overall-progress-bar').style.width = `${progress}%`;
        }



        function updateStats() {
            const today = new Date().toDateString();
            
            const todaySessions = pomodoroData.sessions.filter(s => 
                s.type === 'focus' && new Date(s.completedAt).toDateString() === today
            );
            
            const todayFocusTime = todaySessions.reduce((total, session) => total + session.duration, 0);
            
            document.getElementById('today-stats').textContent = todaySessions.length;
            document.getElementById('focus-time-today').textContent = `${todayFocusTime} min`;
        }

        // Event listeners
        document.getElementById('focusDuration').addEventListener('change', updateSettings);
        document.getElementById('shortBreakDuration').addEventListener('change', updateSettings);



        // Initialize when page loads
        async function init() {
            await initStorage();
            updateDisplay();
            updateTimerProgress();
            
            // Make sure no alarms are running on startup
            stopAlarm();
            
            // No longer need message listeners since we use standard notifications
        }

        window.addEventListener('load', init);
    </script>
</body>
</html>
