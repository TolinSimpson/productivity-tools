<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pomodoro Focus Timer</title>
    <style>
        body { font-family: sans-serif; margin: 0; padding: 0; }
        h1, h3 { margin-top: 0; margin-bottom: 5px; }
        .container { max-width: 800px; margin: 0 auto; padding: 5px; }
        .section { margin-bottom: 10px; padding: 10px; border: 1px solid #eee; position: relative; }
        .control-bar { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .progress-bar-container { height: 12px; background-color: #f0f0f0; border: 1px solid #ccc; margin-top: 10px; border-radius: 3px; }
        .progress-bar-fill { height: 100%; background-color: #000000; transition: width 0.3s ease-in-out; border-radius: 3px; }
        button { padding: 8px 12px; border: 1px solid #ccc; background-color: #f9f9f9; cursor: pointer; }
        button:hover { background-color: #e9e9e9; }
        input[type="text"], input[type="number"] { padding: 8px 12px; border: 1px solid #ccc; }
        .hidden { display: none; }
        [contenteditable]:focus, input:focus { outline: 2px solid black; }
        .btn-row { display: flex; gap: 6px; flex-wrap: wrap; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 8px; }
        .muted { color: #666; font-size: 12px; }
        .big-time { font-variant-numeric: tabular-nums; font-size: 40px; letter-spacing: 1px; }
        ul { list-style: none; padding-left: 0; }
        li { margin-bottom: 6px; }
    </style>
    <link rel="icon" href="data:," />
    <meta name="color-scheme" content="light" />
    <script src="storage.js"></script>
</head>
<body>
    <div class="container" id="main-container">
        <div class="section">
            <div class="control-bar">
                <div style="flex:1">
                    <div>
                        <span id="overall-progress-text">0/0 sessions</span>
                    </div>
                    <div class="progress-bar-container">
                        <div id="overall-progress-bar" class="progress-bar-fill"></div>
                    </div>
                </div>
                <div style="display:flex; align-items:center; gap:6px; margin-left:10px">
                    <input id="projectTitleInput" type="text" value="Pomodoro Focus Timer" />
                    <span id="auto-save-indicator" style="font-size: 12px; color: #666; opacity: 0; transition: opacity 0.3s;">Auto-saved</span>
                </div>
            </div>
        </div>
                 <div class="section">
             <h3>Configuration</h3>
             <div class="grid">
                                   <label>
                      <div class="muted">Focus (minutes)</div>
                      <input id="focusMinutesInput" type="number" min="0.1" step="0.1" value="25" />
                  </label>
                                   <label>
                      <div class="muted">Break (minutes)</div>
                      <input id="breakMinutesInput" type="number" min="0.1" step="0.1" value="5" />
                  </label>
                 <label>
                     <div class="muted">Target sessions</div>
                     <input id="targetSessionsInput" type="number" min="1" value="4" />
                 </label>
                                                               </div>
         </div>

        <div class="section">
            <div style="display:flex; justify-content:space-between; align-items:center">
                <h3>Current Session</h3>
                <div class="muted">Mode: <b id="modeLabel">Focus</b></div>
            </div>
            <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap; margin-bottom:6px">
                <input id="currentTaskInput" type="text" placeholder="Optional task label..." style="flex:1; min-width:220px" />
                <span class="muted">Completed: <b id="sessionsCompletedText">0</b></span>
            </div>
            <div class="big-time" id="timeDisplay">25:00</div>
            <div class="progress-bar-container" style="margin-top:8px">
                <div id="session-progress-bar" class="progress-bar-fill" style="width:0%"></div>
            </div>
            <div class="btn-row" style="margin-top:10px">
                <button data-action="start-focus">Start Focus</button>
                <button data-action="start-break">Start Break</button>
                <button data-action="toggle-pause" id="pauseResumeButton">Pause</button>
                <button data-action="reset-session">Reset Session</button>
            </div>
        </div>

        <div class="section">
            <div style="display:flex; justify-content:space-between; align-items:center">
                <h3>History</h3>
                <button data-action="clear-history">Clear</button>
            </div>
            <ul id="historyList"></ul>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
                         const initialData = {
                 title: 'Pomodoro Focus Timer',
                 focusMinutes: 25,
                 breakMinutes: 5,
                 targetSessions: 4,
                 sessionsCompleted: 0,
                 autoSwitch: false,
                 soundEnabled: true,
                 current: {
                     mode: 'focus', // 'focus' | 'break'
                     totalSeconds: 25 * 60,
                     remainingSeconds: 25 * 60,
                     running: false,
                     taskLabel: ''
                 },
                 history: [] // { id, mode, taskLabel, startedAt, endedAt, plannedSeconds, actualSeconds, status }
             };

            // Load data from storage or use initial data
            let state = window.productivityStorage.loadAppData('pomodoro', initialData);
            if (!state) state = JSON.parse(JSON.stringify(initialData));
            let intervalId = null;

            // Elements
            const projectTitleInput = document.getElementById('projectTitleInput');
            const overallProgressText = document.getElementById('overall-progress-text');
            const overallProgressBar = document.getElementById('overall-progress-bar');

                         const focusMinutesInput = document.getElementById('focusMinutesInput');
             const breakMinutesInput = document.getElementById('breakMinutesInput');
             const targetSessionsInput = document.getElementById('targetSessionsInput');

            const modeLabel = document.getElementById('modeLabel');
            const timeDisplay = document.getElementById('timeDisplay');
            const sessionProgressBar = document.getElementById('session-progress-bar');
            const sessionsCompletedText = document.getElementById('sessionsCompletedText');
            const currentTaskInput = document.getElementById('currentTaskInput');

            const historyList = document.getElementById('historyList');
            const pauseResumeButton = document.getElementById('pauseResumeButton');

            function secondsToMMSS(totalSeconds) {
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                return `${String(minutes).padStart(2,'0')}:${String(seconds).padStart(2,'0')}`;
            }

            function updateOverallProgress() {
                const target = Math.max(1, Number(state.targetSessions) || 1);
                const completed = Math.max(0, Number(state.sessionsCompleted) || 0);
                const pct = Math.min(100, Math.max(0, (completed / target) * 100));
                overallProgressText.textContent = `${completed}/${target} sessions`;
                overallProgressBar.style.width = `${pct}%`;
            }

            function updateSessionUI() {
                modeLabel.textContent = state.current.mode === 'focus' ? 'Focus' : 'Break';
                timeDisplay.textContent = secondsToMMSS(state.current.remainingSeconds);
                const pct = Math.max(0, Math.min(100, (1 - (state.current.remainingSeconds / state.current.totalSeconds)) * 100));
                sessionProgressBar.style.width = isFinite(pct) ? `${pct}%` : '0%';
                sessionsCompletedText.textContent = String(state.sessionsCompleted);
                currentTaskInput.value = state.current.taskLabel || '';
                pauseResumeButton.textContent = state.current.running ? 'Pause' : 'Resume';
            }

            function renderHistory() {
                historyList.innerHTML = '';
                state.history.slice().reverse().forEach(entry => {
                    const li = document.createElement('li');
                    const start = new Date(entry.startedAt);
                    const end = entry.endedAt ? new Date(entry.endedAt) : null;
                    const timeRange = end ? `${start.toLocaleTimeString()} - ${end.toLocaleTimeString()}` : `${start.toLocaleTimeString()} - ...`;
                    const label = entry.taskLabel ? ` • ${entry.taskLabel}` : '';
                    const duration = secondsToMMSS(entry.actualSeconds || 0);
                    li.textContent = `${entry.mode === 'focus' ? 'Focus' : 'Break'}${label} • ${timeRange} • ${duration} • ${entry.status}`;
                    historyList.appendChild(li);
                });
            }

                         function applyConfigToState() {
                 const f = Math.max(0.1, Number(focusMinutesInput.value) || state.focusMinutes);
                 const b = Math.max(0.1, Number(breakMinutesInput.value) || state.breakMinutes);
                 let t = Number(targetSessionsInput.value) || state.targetSessions;
                 
                 // Reset sessions if target is less than 0
                 if (t < 0) {
                     t = 0;
                     state.sessionsCompleted = 0;
                     targetSessionsInput.value = 0;
                 }
                 
                 state.focusMinutes = f;
                 state.breakMinutes = b;
                 state.targetSessions = t;
                 state.autoSwitch = false; // Always false
                 state.soundEnabled = true; // Always true
                 
                 // Reset session when config changes
                 if (state.current.running) {
                     clearInterval(intervalId);
                     stopTimerRecord('Canceled');
                 }
                 const minutes = state.current.mode === 'focus' ? state.focusMinutes : state.breakMinutes;
                 state.current.totalSeconds = Math.round(minutes * 60);
                 state.current.remainingSeconds = Math.round(minutes * 60);
                 state.current.running = false;
                 updateSessionUI();
                 renderHistory();
             }

            function stopTimerRecord(status) {
                if (!state.current._sessionId) return;
                const idx = state.history.findIndex(h => h.id === state.current._sessionId);
                if (idx !== -1) {
                    state.history[idx].endedAt = Date.now();
                    state.history[idx].actualSeconds = state.history[idx].plannedSeconds - state.current.remainingSeconds;
                    state.history[idx].status = status;
                }
                state.current._sessionId = null;
            }

                                      // Audio context for timer alarm
              let audioContext = null;
              let alarmInterval = null;
              let isAlarmPlaying = false;
              
              function playAlarm() {
                  // Only play alarm if sound is enabled
                  if (!state.soundEnabled) return;
                  
                  // Don't start multiple alarms
                  if (isAlarmPlaying) return;
                  
                  isAlarmPlaying = true;
                  
                  try {
                      // Create audio context if it doesn't exist
                      if (!audioContext) {
                          audioContext = new (window.AudioContext || window.webkitAudioContext)();
                      }
                      
                      // Resume audio context if suspended (required for user interaction)
                      if (audioContext.state === 'suspended') {
                          audioContext.resume();
                      }
                      
                      // Start looping alarm
                      playAlarmSequence();
                      alarmInterval = setInterval(playAlarmSequence, 3400); // 3.4 seconds between sequences
                      
                  } catch (error) {
                      console.log('Audio not supported or blocked:', error);
                      isAlarmPlaying = false;
                  }
              }
              
              function playAlarmSequence() {
                  if (!audioContext || audioContext.state !== 'running') return;
                  
                  // Play a more noticeable alarm sequence
                  playAlarmBeep(0, 1000);    // High pitch beep
                  playAlarmBeep(800, 800);   // Medium pitch beep
                  playAlarmBeep(1600, 600);  // Low pitch beep
                  playAlarmBeep(2400, 1000); // High pitch beep again
              }
              
              function stopAlarm() {
                  if (alarmInterval) {
                      clearInterval(alarmInterval);
                      alarmInterval = null;
                  }
                  isAlarmPlaying = false;
              }
              
              function playAlarmBeep(delay, frequency) {
                  setTimeout(() => {
                      if (!audioContext || audioContext.state !== 'running') return;
                      
                      const oscillator = audioContext.createOscillator();
                      const gainNode = audioContext.createGain();
                      
                      oscillator.connect(gainNode);
                      gainNode.connect(audioContext.destination);
                      
                      // Configure sound - louder and more noticeable
                      oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                      oscillator.type = 'square'; // Square wave for more piercing sound
                      
                      // Configure volume envelope - much louder
                      gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                      gainNode.gain.linearRampToValueAtTime(0.8, audioContext.currentTime + 0.05); // Higher volume
                      gainNode.gain.linearRampToValueAtTime(0.8, audioContext.currentTime + 0.3);  // Sustain
                      gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.6);    // Fade out
                      
                      // Play the sound
                      oscillator.start(audioContext.currentTime);
                      oscillator.stop(audioContext.currentTime + 0.6);
                      
                  }, delay);
              }
             
                                        function startTimer(mode) {
                 // Stop any playing alarm when starting a new timer
                 stopAlarm();
                 
                 clearInterval(intervalId);
                 state.current.mode = mode;
                 const minutes = mode === 'focus' ? state.focusMinutes : state.breakMinutes;
                 state.current.totalSeconds = Math.round(minutes * 60);
                 state.current.remainingSeconds = Math.round(minutes * 60);
                 state.current.running = true;
                 state.current.taskLabel = currentTaskInput.value || '';

                 const sessionId = `sess-${Date.now()}`;
                 state.current._sessionId = sessionId;
                 state.history.push({
                     id: sessionId,
                     mode,
                     taskLabel: state.current.taskLabel,
                     startedAt: Date.now(),
                     endedAt: null,
                     plannedSeconds: state.current.totalSeconds,
                     actualSeconds: 0,
                     status: 'Running'
                 });
                 renderHistory();

                 intervalId = setInterval(() => {
                     if (!state.current.running) return;
                     state.current.remainingSeconds = Math.max(0, state.current.remainingSeconds - 1);
                     updateSessionUI();

                     if (state.current.remainingSeconds === 0) {
                         clearInterval(intervalId);
                         stopTimerRecord('Completed');
                         
                         // Play alarm when timer completes
                         playAlarm();
                         
                         if (state.current.mode === 'focus') {
                             state.sessionsCompleted += 1;
                         }
                         updateOverallProgress();
                         renderHistory();
                         // Auto-save after session completion
                         window.productivityStorage.autoSave('pomodoro', state);
                         showAutoSaveIndicator();

                         // Always stop the timer and keep alarm playing until user takes action
                         state.current.running = false;
                         updateSessionUI();
                     }
                 }, 1000);

                 updateSessionUI();
             }

                         function togglePause() {
                 // Stop alarm when pausing/resuming
                 stopAlarm();
                 state.current.running = !state.current.running;
                 pauseResumeButton.textContent = state.current.running ? 'Pause' : 'Resume';
             }

             function resetSession() {
                 // Stop alarm when resetting session
                 stopAlarm();
                 clearInterval(intervalId);
                 stopTimerRecord('Canceled');
                 const minutes = state.current.mode === 'focus' ? state.focusMinutes : state.breakMinutes;
                 state.current.totalSeconds = Math.round(minutes * 60);
                 state.current.remainingSeconds = Math.round(minutes * 60);
                 state.current.running = false;
                 updateSessionUI();
                 renderHistory();
             }

            

                         function syncInputsFromState() {
                 projectTitleInput.value = state.title;
                 focusMinutesInput.value = state.focusMinutes;
                 breakMinutesInput.value = state.breakMinutes;
                 targetSessionsInput.value = state.targetSessions;
             }

            // Button actions
            document.body.addEventListener('click', async (event) => {
                const target = event.target;
                const action = target.dataset.action;
                if (!action) return;

                switch (action) {
                    
                    case 'start-focus':
                        startTimer('focus');
                        break;
                    case 'start-break':
                        startTimer('break');
                        break;
                    case 'toggle-pause':
                        togglePause();
                        break;
                    case 'reset-session':
                        resetSession();
                        break;
                                         case 'clear-history':
                         state.history = [];
                         renderHistory();
                         // Auto-save after clearing history
                         window.productivityStorage.autoSave('pomodoro', state);
                         showAutoSaveIndicator();
                         break;

                }
            });

            function showAutoSaveIndicator() {
                const indicator = document.getElementById('auto-save-indicator');
                indicator.style.opacity = '1';
                setTimeout(() => {
                    indicator.style.opacity = '0';
                }, 2000);
            }

                         // Live updates
             projectTitleInput.addEventListener('input', (e) => {
                 state.title = e.target.value;
                 // Auto-save after title change
                 window.productivityStorage.autoSave('pomodoro', state);
                 showAutoSaveIndicator();
             });
             currentTaskInput.addEventListener('input', (e) => {
                 state.current.taskLabel = e.target.value;
                 // Auto-save after task label change
                 window.productivityStorage.autoSave('pomodoro', state);
                 showAutoSaveIndicator();
             });
             
             // Auto-apply config changes
             focusMinutesInput.addEventListener('input', () => {
                 applyConfigToState();
                 updateOverallProgress();
                 window.productivityStorage.autoSave('pomodoro', state);
                 showAutoSaveIndicator();
             });
             breakMinutesInput.addEventListener('input', () => {
                 applyConfigToState();
                 updateOverallProgress();
                 window.productivityStorage.autoSave('pomodoro', state);
                 showAutoSaveIndicator();
             });
             targetSessionsInput.addEventListener('input', () => {
                 applyConfigToState();
                 updateOverallProgress();
                 window.productivityStorage.autoSave('pomodoro', state);
                 showAutoSaveIndicator();
             });

            // Init
            syncInputsFromState();
            updateOverallProgress();
            updateSessionUI();
            renderHistory();
        });
    </script>
</body>
</html>


